pragma solidity 0.5.0;

contract sendYou{
    
  function transfer(address payable _receiver, uint256 _value) payable external {
    address(_receiver).transfer(_value);
  }
  
  function send(address payable _receiver, uint256 _value) payable external{
      (bool success, ) = address(_receiver).call.value(_value)("");
        require(success, "Transfer failed.");
  }

  //To avoid Re-entrancy in using call.value
  
  function withdraw() external{
         uint256 amount = balanceOf[msg.sender];
         balanceOf[msg.sender] = 0; // typical safeguard for re-entrancy
         (bool success, ) = msg.sender.call.value(amount)("");
         require(success, "Transfer failed.");
  }
  /**
  If msg.sender is a smart contract, it has an opportunity on line 19 to call withdraw() again before line 20 happens. 
  In that second call, balanceOf[msg.sender] is still the original amount, so it will be transferred again. 
  This can be repeated as many times as necessary to drain the smart contract.
  
  NB: you can use https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol 
  **/
  
  function () payable external{
  //this seems to be needed for v0.5.0
  }
}
